<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>prototype</title>
</head>

<body>
  <h1>prototype</h1>
  <p>1. 构造函数 function Person(){}</p>
  <p>1. 实例 let p1 = new Person()</p>
  <p>2. 原型 Person.prototype 、 p1.__proto__ </p>
  <p>3. 原型链: 原型与原型层层相链接的过程即为原型链 </p>
  <p>4. 实例与原型：实例的__proto__即是原型 </p>
  <p>5. 构造函数与原型：构造函数的prototype即是原型 </p>
  <p>6. 实例与构造函数：实例为new构造函数返回的新对象，每次new的都是新对象；实例的constructor是构造函数 </p>

  <!-- 原型的使用场景 -->
  <p>instanceof：原理为利用原型及原型链判断实例对象与构造函数之间的关系。只能判断object，基础类型无法判断</p>


  <script>
    function Person (name) {
      this.name = name;
    }
    Person.prototype.getName = function () {
      console.log(this.name);
    }

    let p1 = new Person('p1');
    Person.prototype.getTime = function () {
      console.log(new Date());
    }
    let p2 = new Person('p2');


    console.log(p1.__proto__ === Person.prototype); // true

    // 原型上添加的方法，实例都可以访问到，且为同一个方法
    console.log(p1.getName === p2.getName); // true
    console.log(p1.getTime === p2.getTime); // true


    console.log(p1.constructor === Person); // true


  </script>
</body>

</html>